% toolpath.tex

\documentclass[main.tex]{subfiles}
\begin{document}

\chapter{Robot Programming}
Two options are commonly available for programming most industrial robots: produce a standard G-code program and run it through the robot's G-code interpreter or use the robot's native programming language.
Using G-code is useful when the robot's tool paths will be generated by standard computer aided manufacturing (CAM) software packages.
\nomenclature[A]{CAM}{Computer Aided Manufacturing}
Most facilities with CNC machines already have access to CAM software and knowledgeable operators making it easy to transition from programming CNC machines to programming a robot.
CAM packages are also essential when tool paths require thousands to hundreds of thousands of points for complex machining or polishing applications.
There are, however, some disadvantages associated with using G-code on a robot.
The first disadvantage with G-code is that since it was originally designed for operating three axis CNC machines and only later expanded to handle more axes, it does not provide as rich of a command set for operating a robot as the robot's native language.
This can limit a programmer's ability to access robot specific reposition commands, handle advanced motion planning tasks, or interface with external devices.

A second disadvantage lies in needing to know the implementation and reliability of the robot's G-code interpreter.
Knowing which G-codes are implemented is usually simple but understanding the subtle differences which can occur between implementations can be difficult.
How will the robot move when G-code commands cause it to move near a singularity or require a different robot configuration to prevent a crash?
While these problems can also occur when using the robot's native language they become more opaque and difficult to predict with an additional layer of abstraction between the operator/programmer and the actual robot motions.

Due to the limitations present in using G-code to program the robot it was decided to use ABB's proprietary RAPID programming language for operating the robot.
By using the RAPID language it is possible to directly control the quaternions and robot configuration parameters for each point along a path making it easier to command off-axis work.
Communication between the robot and RAMBo board is easier with RAPID plus the RobotStudio environment simplifies program debugging.
For 2.5D printing it was possible to modify SciSlice to output RAPID programs instead of G-code enabling easy initial testing of the system.
When off-axis tool paths were required additional Python scripts were developed to produce the desired robot code.

When creating RAPID programs the most essential elements for making the robot move as desired are tool and work objects, motion commands, and the desired movement points.
The tool and work objects, sec. \ref{sec:toolworkobjects}, tell the robot where the tool and build platform are located providing a reference frame for the coordinate system.
Motions commands, sec. \ref{sec:motioncommands}, define how the robot should move between programmed points, i.e. straight line, arc, joint etc..
While points, or \texttt{robTarget}s, sec. \ref{sec:points}, define where the robot should move, what posture the tool should be in, and the desired robot configuration.
With these three basic items and knowledge of the robot's syntax, it is possible to create off-axis programs for the robot.



\section{Tool and Work Objects}
\label{sec:toolworkobjects}
As is done in CNC machine programming, tool and work offsets can and should be used when programming robots.
In ABB's RAPID programming language these offsets are stored in variable objects of types \texttt{tooldata} and \texttt{wobjdata}, respectively.
Unlike in CNC operations, the RAPID programming language allows a user to declare whether the robot is holding the tool or the work object.
Most applications use a robot held tool with a fixed work object but for this application it was decided to use a robot held work object (build platform) and a fixed tool (print head).
By using a robot held work object the $xyz$ coordinates used for commanding program positions become fixed to the part enabling the robot to track their locations as the part is rotated.
Calculating where the part is in space as the robot rotates, called the forward kinematics, is not overly complicated but it is work best completed by the robot itself.
With this setup a point on the part is always the same $xyz$ coordinates independent of the part's angle relative to the nozzle.
Commanding the robot to be at the same point with different orientations is done by using the same $xyz$ values and only changing the \texttt{robTarget}'s quaternion.
This makes it easy for the operator to know where on the part the robot is moving and which locations will have different orientations.
If a robot held tool and fixed work object had been used different positions around the part could be commanded with the same $xyz$ values but different quaternions, a situation deemed very difficult to read and troubleshoot.

Using tool and work objects also enables the operator to make adjustments to the tool path without editing and reloading the entire program.
If the operator notices that a new build platform was causing the initial layers of a part to be printed too high they could go into the work object representing the build platform and adjust it, fixing the tool path problem without changing the program.
It should be noted that in this situation the changing of the build platform made it obvious as to which object, tool or work, was causing the problem.
In other situations the adjustment required may not be so clear and special care should be taken when adjusting the location of the nozzle.
An adjustment in $z$\nobreakdash-height of the nozzle may fix a problem in the $xy$\nobreakdash-plane but create a new one when the work piece is rotated into a new orientation.

\subsection{Measuring the Nozzle}
As mentioned in section \ref{sec:challangenozzle}, accurately measuring the location of the nozzle in $xyz$ is critical to the quality of off-axis printed parts.
To measure the nozzle's location a 3-axis analog indicator made by Haimer, their Universal 3D-Sensor, was used which is accurate to \SI{10}{\micro m}.
A custom adapter was designed and then machined out of aluminum to attach the  3D-sensor to the robot, Fig.~\ref{fig:3Dsensor}.

\begin{figure}
\centering
	\begin{overpic}[width=0.8\textwidth, keepaspectratio]
		{3DSensor.pdf}
		\put(70,43){Robot Arm}
		\put(45,35){Adapter}
		\put(43,1.5){3D Sensor}
		\put(15,12){\makebox(0,0)[r]{Stylus on nozzle}}
	\end{overpic}
	\caption{Haimer 3D Sensor measuring nozzle location.}
	\label{fig:3Dsensor}
\end{figure}

\subsubsection{3D-Sensor Calibration}
Before making accurate measurements with the 3D-sensor the run-out of the tool must be minimized and the gauge length needs to be properly calibrated.
Run-out is minimized by adjusting the four run-out screws on the sensor and checked by rotating the sixth axis while the stylus is contacting a dial indicator.
With patience a run-out of less than \SI{2}{\micro m} can be achieved.

The gauge length of the sensor is measured from the mounting face of the sixth axis to the position of the stylus's tip when the dial reads zero in the $z$ direction.
To calibrate this value a reference location with a known $z$\nobreakdash-height must be developed.
This reference location was developed by commanding the sixth axis to be parallel with the safety enclosure's table and then driving the robot until a gauge block just fit between the table and the sixth axis's face.
From here the robot's $z$\nobreakdash-height is checked and by accounting for the height of the gauge block the $z$\nobreakdash-height of the reference position is known.
After the sensor is mounted on the robot and the run-out is adjusted the sixth axis is again placed parallel to the table and the robot is driven down until the 3D sensor reads zero.
The difference between the robot's $z$\nobreakdash-height in this position and that of the reference position is the gauge length of the tool.

\subsubsection{Measuring}
After properly calibrating the 3D sensor it is possible to begin measuring the $xyz$ location of the nozzle.
The flat end of the nozzle makes measuring its $z$\nobreakdash-height straight forward, drive the stylus into the nozzle until the reading is zero and record the $z$ value, but it is more difficult to measure the $xy$ location.
The technique used to measure the $xy$ location was to first drive the stylus into the nozzle until \SI{100}{\micro m} of deflection were observed.
Second the stylus was moved in the the desired direction until the ball started sliding off the flat face and \SI{10}{\micro m} of reduced deflection was observed, this $x$ or~$y$ location was recorded.
Third this process was repeated in the opposite direction with the appropriate location again being recorded.
Finally these two values were averaged to determine the center of the flat, Fig.~\ref{fig:nozzlemeasuring}.

\begin{figure}
\centering
        \begin{overpic}[width=0.7\textwidth, keepaspectratio]
        	{NozzleMeasure.pdf}
        	\put(18,5){\makebox(0,0)[r]{Step 2}}
        	\put(39,4){Step 3}
        	\put(49,45.5){Nozzle}
        	\put(79,62){\makebox(0,0)[c]{3D Sensor}}
        \end{overpic}
        \caption{Steps for measuring the $x$ or $y$ location of the nozzle.}%
        \label{fig:nozzlemeasuring}
\end{figure}

\begin{table}
\centering
	\caption{Nozzle location measurements}
    \begin{tabular}{r c c c c c}
    \toprule
    & \multicolumn{3}{c}{Nozzle Location (\si{mm})}\\ 
    \cmidrule(r){2-4}
    No. & X & Y & Z & Quaternion & Axis Angle\tablefootnote{Axis angles rounded to nearest degree to provide approximate robot configuration.} (\si{\degree})\\
    \midrule
    1 & -22.16 & -433.71 & 636.59 & (0.27, 0.65, 0.27, -0.65) & (-66, 3, -4, 91, -68, 91)\\
    2 & -20.97 & -433.81 & 636.77 & (0.5, 0.5, 0.5, -0.5) & (95, -15, 12, -119, -6, 120)\\
    \addlinespace
    3 & -21.00 & -433.5 & 636.96 & (0.65, 0.27, 0.65, -0.27) & (-120, 7, -8, 90, -75, 91)\\
    4 & -21.82 & -434.04 & 636.69 & (0.65, 0.27, 0.65, -0.27) & (-120, 7, -9, 90, 75, 271)\\
    \addlinespace
    5 & -21.60 & -433.38 & 636.81 & (0.65, 0.27, 0.27, -0.65) & (-94, -3, 29, -3, -70, 4)\\
    6 & -21.24 & -433.35 & 636.91 & (0.71, 0, 0.5, -0.5) & (-117, 13, 4, -59, -91, 36)\\
    7 & -21.87 & -433.41 & 636.79 & (0.5, 0.5, 0, -0.71) & (-69, 9, 8, 57, -86, -32)\\
    \midrule
    & 0.40 & 0.23 & 0.11 & \multicolumn{1}{l}{Standard Deviation} \\
    \cmidrule(r){2-5}
    & -21.52 & -433.60 & 636.79 & \multicolumn{1}{l}{Average} \\
    \bottomrule    
    \end{tabular}        
        \label{table:nozzlemeasurements}
\end{table}

To quantify and potentially compensate for pose inaccuracies the measuring procedure was repeated for seven different robot poses, Table \ref{table:nozzlemeasurements}.
Considerable variations were found in the $x$ and~$y$ directions which were caused by a combination of measuring difficulty and pose inaccuracy.
The $z$\nobreakdash-height is the most critical of the three dimensions and shows the least variation between measurements.
The averages of these values were used for the nozzle's tool data.

After performing several test prints it was found that the $z$\nobreakdash-height of the nozzle was \SIrange{200}{300}{\micro m} too low both when the platform was normal to the nozzle and when it was rotated to print around the outside of the part.
Placing the 3D sensor back on the robot provided numbers which showed that the entered $z$\nobreakdash-height was correct.
Additional testing revealed that the combined mass of the 3D sensor and adapter, \SI{680}{g}, cause the robot to deflect downward by \SI{250}{\micro m}.
Since the inline build platform has a mass of only \SI{72}{g} it does not deflect the robot down as far thus making the nozzle too close to the print.
Upon discovering this deflection the $z$ location of the nozzle was moved upward by \SI{250}{\micro m} fixing the $z$\nobreakdash-height problem.

\subsection{Measuring the Build Platform}
Measuring of the build platform was only necessary for the \ang{45} platform.
The inline platform, being a much simpler design, could be measured offline and its data manually entered.
When measured offline only the distance from the sixth axis's mounting face to the end of the platform is needed to set the $z$ value, both the $x$ and~$y$ values are set to zero and the orientation quaternion is set to $(0,-1,0,0)$ which signifies that the $z$ direction of the platform is straight away from the sixth axis.

Due to the difficulty in using offline techniques to measure the angled build platform it must be measured when attached to the robot.
Because of the platform's size and inaccuracies in manufacturing and assembly, both the location and angle of the platform relative to the sixth axis must be known to ensure proper nozzle heights when printing a part's first layer.
The robot provides a calibration routine which uses three measured points to automatically calculate the work object's distance and quaternion offsets from the sixth axis.

A modified tool setter was used to measure the three points needed for calibrating the angled build platform's work offset.
The tool setter is a Precise Dial Z-Axis Setter, no.~4401-0063, which had its original steel body replaced with a FFF printed ABS body to reduce its weight.
The weight reduction had been done to enable more precise print bed leveling on a standard 2.5D printer in the lab but was a useful modification here as well preventing additional deflection of the robot while measuring the work object.
When measuring the build platform the robot is first moved until the platform is under and approximately normal to the nozzle.
Next the tool setter is calibrated to a height of \SI{50}{mm} with a caliper and placed on the build platform.
Three points are chosen near the edges of the platform to provide the most $z$\nobreakdash-height difference if the platform is not at the correct angular position.
To control the orientation of the work coordinate system the three points are chosen in the order shown in Figure~\ref{fig:bedcalibration} with the first two points aligned with the robot's $x$\nobreakdash-axis for easier machine operation.
At each of the three points the platform's height is adjusted until the tool setter reads \SI{50}{mm} between the nozzle and the platform.

\begin{figure}
\centering
        \begin{overpic}[width=0.7\textwidth, keepaspectratio]
        	{BedLevelOrder.pdf}
        	\put(5.5,45.5){Nozzle}
        	\put(39,58){Build Platform}
        	\put(71, 58){Robot Arm}
        	\put(50,4){\makebox(0,0)[c]{\large{Main Operator Door}}}
        	\put(40,20){\textbf{1}}
        	\put(40,40){\textbf{2}}
        	\put(23,20){\textbf{3}}
        \end{overpic}
        \caption{Top view of platform showing order and location of work object calibration points.}%
        \label{fig:bedcalibration}
\end{figure}

After the calibration data is loaded into the work object the robot is commanded to move normal to and \SI{50}{mm} away from the nozzle.
The tool setter is then placed back on the platform and the calibration is checked.
Tests showed a total indicator runout, TIR, of only \SI{40}{\micro m}, within the flatness tolerance of the build plate itself.
\nomenclature[A]{TIR}{Total Indicator Runout}

It should be noted that the robot needs to know the mass and moment of its EOA tooling to ensure the acceleration and jerk movement parameters do not cause axis overloads.
This parameter is stored in the \texttt{tooldata} object.
When a \texttt{workobj} has its \texttt{robheld} parameter set to true the robot will read the tool mass and moment data from the active tool and apply it to the work object.

\section{Robot Motion Commands}
\label{sec:motioncommands}
There are two main programming techniques for commanding the robot's motion.
The first technique directly commands the angle for each axis while the second technique provides a desired path and an ending \texttt{robTarget} enabling the robot to calculate its own axis angle commands for the desired motion.
The \texttt{moveAbsJ} command is used when programming with the first technique.
With this command the absolute joint angles and tool center point, TCP, velocity are specified.
\nomenclature[A]{TCP}{Tool Center Point}
Each joint then moves at a speed such that the TCP velocity is maintained and all joints simultaneously reach their end position.
While this technique enables precise control over the robot, it has several disadvantages that make it infeasible for most programming applications.
One of the disadvantages is that if straight line motion is required, many waypoints along the path need to be calculated and then commanded making the program quite long and difficult to read.
A second disadvantage of using the \texttt{moveAbsJ} command is that it cannot use work and tool objects requiring recalculation of the entire program if either object needs adjustment.

A more desirable programming technique for off-axis printing is to use one of several RAPID provided movement commands depending upon which type of motion, linear, circular, joint, etc., is desired.
With these movement commands a desired \texttt{robTarget} is programmed and the robot calculates the waypoints required to move the robot along the intended path to the end location.
This greatly reduces the number of programmed points required and declares to the operator what type of motion the robot will make.
There are several limitations the robot places on these commands to ensure unexpected moves are not made.
The first limitation is that a single motion command is not allowed to move an axis on the robot more than \ang{90}.
This limitation is typically encountered when repositioning a print and not during normal printing paths.

The second limitation is the motion commands must avoid singularities, sec.~\ref{sec:singularity}.
During a singularity it is ambiguous as to which axis should move and how far.
For example, when a wrist singularity is encountered both the fourth and sixth axes cause motion about the same axis of rotation.
Instead of leaving the programmer/operator unable to know which axis the robot will choose to rotate, the robot instead sends an alarm and stops.
Moves which create singularities or cause axis over travel alarms are not checked for at program load time but are instead checked at runtime.
Simulation software such as RobotStudio or other third party software can be used to execute programs and check for execution time errors before they are encountered on the robot.

\section{Coordinates/Points}
\label{sec:points}
Coordinates are stored in RAPID as data of type \texttt{robTarget}.
\texttt{robTarget}s store three pieces of information about the point they represent: $xyz$ location, orientation quaternion, and the desired configuration of the robot, \texttt{robConfig}.
The $xyz$ location is in standard Euclidean space and is referenced from the active tool and work objects.
The quaternion used for controlling orientation represents the three rotational degrees of freedom with four numbers and must have a norm of one.
%Using four values in quaternions prevents representation singularities from occurring as can happen when using Euler angles or other three value representations and is more compact than a 3x3 rotation matrix.
These two parameters fully constrain the location and orientation of the robot held object but do not fully constrain the robot's axes values since some locations and orientations can be achieved by different axis angle combinations.
To clarify which combination is desired \texttt{robConfig} defines the location of axes 1, 4, and 6 in units of quarter turns from zero.
Together, these three parameters define a point's location, orientation, and desired axes positions.  

\section{System Communication}
As mentioned in section \ref{sec:interface}, the robot and print head communicate through the RAMBo board over multi-channel digital I/O.
The \texttt{SetDO} command sets the digital outputs either high or low while the \texttt{WaitDI} command waits until the print bed and extruder are up to temperature.
When setting the numeric values of temperature and extrusion rate the \texttt{WaitTime} command is used.


\section{Process Flow}
The RAPID program contains both the robot motion commands and the print head commands.
When a print head command is executed in the program a digital output is triggered on the robot's IRC5 controller.
This signal goes into the RAMBo enclosure where it is stepped down from \SI{24}{V} to \SI{5}{V} by an opto-coupler and a relay.
The \SI{5}{V} signal is then read by the RAMBo board.
If the signal is received while the RAMBo program is in the appropriate state the corresponding action will occur.
These actions can include sending drive signals to the stepper motor or adjusting the PWM signal to the heaters.
\nomenclature[A]{PWM}{Pulse Width Modulation}
Temperature information for the nozzle and bed are measured by thermocouples and read by the RAMBo board providing closed loop control of these values.
Nozzle and bed ``at temperature'' signals are currently the only communication from the RAMBo board back to the robot controller, Fig.~\ref{fig:progflow}.

\begin{figure}
\centering
    \includegraphics[]{ProgFlow.tikz}
\caption{Flow of commands and information during program execution.}
\label{fig:progflow}
\end{figure}

\end{document}
